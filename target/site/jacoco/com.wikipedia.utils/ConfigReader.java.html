<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pt"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConfigReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Appium Wikipedia Framework - Mobile Test Automation</a> &gt; <a href="index.source.html" class="el_package">com.wikipedia.utils</a> &gt; <span class="el_source">ConfigReader.java</span></div><h1>ConfigReader.java</h1><pre class="source lang-java linenums">package com.wikipedia.utils; // Pacote ajustado conforme sua estrutura

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Properties;

/**
 * Classe utilitária para ler as configurações do arquivo config.properties.
 * Utiliza o padrão Singleton (via inicialização estática) para garantir que as propriedades sejam carregadas apenas uma vez por arquivo.
 * Inclui métodos para carregar arquivos de teste e restaurar o padrão.
 */
public class ConfigReader {

<span class="fc" id="L20">    private static final Logger logger = LoggerFactory.getLogger(ConfigReader.class);</span>
    // Caminho padrão para o arquivo de configuração principal
    private static final String DEFAULT_CONFIG_FILE_PATH = &quot;src/test/resources/config.properties&quot;;
    private static Properties properties;
    // Variável para rastrear qual arquivo de configuração está atualmente carregado
<span class="fc" id="L25">    private static String currentConfigPath = DEFAULT_CONFIG_FILE_PATH;</span>

    // Bloco estático para carregar as propriedades padrão na inicialização da classe
    static {
<span class="fc" id="L29">        loadProperties(DEFAULT_CONFIG_FILE_PATH); // Carrega o arquivo padrão</span>
<span class="fc" id="L30">    }</span>

    // Construtor privado para evitar instanciação externa
    private ConfigReader() {}

    /**
     * Carrega as propriedades do arquivo de configuração especificado.
     * Este método é privado e sincronizado para garantir a atomicidade ao trocar as propriedades.
     * @param filePath O caminho para o arquivo .properties a ser carregado.
     */
    private static synchronized void loadProperties(String filePath) {
<span class="fc" id="L41">        properties = new Properties(); // Sempre cria um novo objeto Properties para limpar o anterior</span>
<span class="fc" id="L42">        currentConfigPath = filePath; // Atualiza o caminho atual</span>
<span class="fc" id="L43">        logger.info(&quot;Carregando propriedades do arquivo: {}&quot;, filePath);</span>

        // Verifica se o arquivo existe antes de tentar carregar
<span class="fc bfc" id="L46" title="All 2 branches covered.">        if (!Files.exists(Paths.get(filePath))) {</span>
<span class="fc" id="L47">            logger.error(&quot;Arquivo de configuração não encontrado em: {}&quot;, filePath);</span>
            // Lança uma exceção pois a configuração é essencial
<span class="fc" id="L49">            throw new RuntimeException(&quot;Arquivo de configuração não encontrado: &quot; + filePath);</span>
        }

        // Usa try-with-resources para garantir o fechamento do InputStream
<span class="fc" id="L53">        try (InputStream input = new FileInputStream(filePath)) {</span>
<span class="fc" id="L54">            properties.load(input);</span>
<span class="fc" id="L55">            logger.info(&quot;Propriedades carregadas com sucesso de {}.&quot;, filePath);</span>
            // Logar algumas propriedades essenciais para verificação (opcional, nível DEBUG)
            // logger.debug(&quot;platformName (de {}): {}&quot;, filePath, properties.getProperty(&quot;platformName&quot;));

<span class="nc" id="L59">        } catch (IOException ex) {</span>
<span class="nc" id="L60">            logger.error(&quot;Erro ao carregar o arquivo de configuração: {}&quot;, filePath, ex);</span>
            // Lança uma exceção para indicar falha crítica
<span class="nc" id="L62">            throw new RuntimeException(&quot;Não foi possível carregar o arquivo de configuração: &quot; + filePath, ex);</span>
<span class="fc" id="L63">        }</span>
<span class="fc" id="L64">    }</span>

    /**
     * [MÉTODO PARA TESTES UNITÁRIOS]
     * Força o carregamento de propriedades de um arquivo específico, substituindo as atuais.
     * Use com cuidado e sempre restaure com resetToDefaultProperties() após o teste.
     * @param testFilePath Caminho para o arquivo de propriedades de teste.
     */
    public static synchronized void loadTestProperties(String testFilePath) {
<span class="fc" id="L73">        logger.warn(&quot;--- CARREGANDO PROPRIEDADES DE TESTE DE: {} ---&quot;, testFilePath);</span>
<span class="fc" id="L74">        loadProperties(testFilePath);</span>
<span class="fc" id="L75">    }</span>

    /**
     * [MÉTODO PARA TESTES UNITÁRIOS]
     * Restaura o carregamento para o arquivo de propriedades padrão (definido em DEFAULT_CONFIG_FILE_PATH).
     * Deve ser chamado em um método @AfterAll ou @AfterEach nos testes unitários.
     */
    public static synchronized void resetToDefaultProperties() {
        // Só recarrega se o arquivo atual NÃO for o padrão
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">        if (!currentConfigPath.equals(DEFAULT_CONFIG_FILE_PATH)) {</span>
<span class="fc" id="L85">            logger.warn(&quot;--- RESTAURANDO PROPRIEDADES PADRÃO DE: {} ---&quot;, DEFAULT_CONFIG_FILE_PATH);</span>
<span class="fc" id="L86">            loadProperties(DEFAULT_CONFIG_FILE_PATH);</span>
        } else {
<span class="nc" id="L88">            logger.debug(&quot;Propriedades padrão já estavam carregadas. Nenhuma ação necessária.&quot;);</span>
        }
<span class="fc" id="L90">    }</span>

    /**
     * Obtém o valor de uma propriedade de configuração atualmente carregada.
     *
     * @param propertyName A chave (nome) da propriedade desejada.
     * @return O valor da propriedade como String, ou null se a propriedade não for encontrada.
     */
    public static String getProperty(String propertyName) {
        // Verifica se 'properties' foi inicializado (embora o bloco estático deva garantir isso)
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        if (properties == null) {</span>
<span class="nc" id="L101">            logger.error(&quot;Objeto Properties não inicializado ao buscar '{}'. Verifique o fluxo de inicialização.&quot;, propertyName);</span>
            // Tentar recarregar pode mascarar o problema original, melhor falhar ou retornar null.
<span class="nc" id="L103">            return null;</span>
            // Se optar por tentar recarregar:
            // logger.warn(&quot;Tentando recarregar propriedades de {}.&quot;, currentConfigPath);
            // loadProperties(currentConfigPath);
            // if (properties == null) return null; // Se ainda falhar
        }
<span class="fc" id="L109">        String value = properties.getProperty(propertyName);</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        if (value == null) {</span>
            // Usar WARN para propriedades não encontradas é útil para debug
<span class="fc" id="L112">            logger.warn(&quot;Propriedade '{}' não encontrada no arquivo {}&quot;, propertyName, currentConfigPath);</span>
        }
        // Log TRACE pode ser útil para depuração detalhada
        // logger.trace(&quot;Obtendo propriedade: {} = {}&quot;, propertyName, value);
<span class="fc" id="L116">        return value;</span>
    }

    /**
     * Obtém o valor de uma propriedade de configuração, retornando um valor padrão se não for encontrada.
     *
     * @param propertyName A chave (nome) da propriedade desejada.
     * @param defaultValue O valor padrão a ser retornado se a chave não existir.
     * @return O valor da propriedade como String, ou o valor padrão.
     */
    public static String getProperty(String propertyName, String defaultValue) {
<span class="fc" id="L127">        String value = getProperty(propertyName);</span>
        // Retorna o valor lido se não for nulo, caso contrário retorna o padrão
<span class="fc bfc" id="L129" title="All 2 branches covered.">        return (value != null) ? value : defaultValue;</span>
    }

    /**
     * Obtém o valor de uma propriedade de configuração como um Inteiro.
     *
     * @param propertyName A chave (nome) da propriedade desejada.
     * @param defaultValue O valor padrão a ser retornado se a propriedade não for encontrada ou não for um número inteiro válido.
     * @return O valor da propriedade como int, ou o valor padrão.
     */
    public static int getIntProperty(String propertyName, int defaultValue) {
<span class="fc" id="L140">        String value = getProperty(propertyName);</span>
<span class="pc bpc" id="L141" title="1 of 4 branches missed.">        if (value != null &amp;&amp; !value.trim().isEmpty()) { // Verifica também se não está vazio após trim</span>
            try {
                // trim() remove espaços extras antes de tentar converter
<span class="fc" id="L144">                return Integer.parseInt(value.trim());</span>
<span class="fc" id="L145">            } catch (NumberFormatException e) {</span>
                // Log mais detalhado sobre a falha de conversão
<span class="fc" id="L147">                logger.warn(&quot;Falha ao converter a propriedade '{}' ('{}') do arquivo {} para inteiro. Usando valor padrão: {}. Erro: {}&quot;,</span>
<span class="fc" id="L148">                        propertyName, value, currentConfigPath, defaultValue, e.getMessage());</span>
<span class="fc" id="L149">            }</span>
<span class="pc bpc" id="L150" title="3 of 4 branches missed.">        } else if (value != null &amp;&amp; value.trim().isEmpty()){</span>
<span class="nc" id="L151">            logger.warn(&quot;Propriedade '{}' está presente mas vazia no arquivo {}. Usando valor padrão: {}&quot;, propertyName, currentConfigPath, defaultValue);</span>
        }
        // Retorna o padrão se a propriedade não existe, está vazia ou falhou na conversão
<span class="fc" id="L154">        return defaultValue;</span>
    }

    // --- Constantes para as chaves das propriedades essenciais (Boa prática) ---
    public static final String PLATFORM_NAME = &quot;platformName&quot;;
    public static final String AUTOMATION_NAME = &quot;automationName&quot;;
    public static final String DEVICE_NAME = &quot;deviceName&quot;;
    public static final String APP_PACKAGE = &quot;appPackage&quot;;
    public static final String APP_WAIT_ACTIVITY = &quot;appWaitActivity&quot;;
    public static final String IMPLICIT_WAIT = &quot;implicitWaitTimeout&quot;; // Em segundos
    public static final String APPIUM_SERVER_URL = &quot;appiumServerUrl&quot;;
    // Adicione outras constantes conforme necessário

    // --- Métodos de acesso convenientes para propriedades comuns (Opcional, mas recomendado) ---

    public static String getPlatformName() {
<span class="fc" id="L170">        return getProperty(PLATFORM_NAME);</span>
    }

    public static String getAutomationName() {
<span class="nc" id="L174">        return getProperty(AUTOMATION_NAME);</span>
    }

    public static String getDeviceName() {
<span class="fc" id="L178">        return getProperty(DEVICE_NAME);</span>
    }

    public static String getAppPackage() {
<span class="nc" id="L182">        return getProperty(APP_PACKAGE);</span>
    }

    public static String getAppWaitActivity() {
<span class="nc" id="L186">        return getProperty(APP_WAIT_ACTIVITY);</span>
    }

    public static int getImplicitWait() {
        // Padrão de 10 segundos se não definido no arquivo ou inválido
<span class="fc" id="L191">        return getIntProperty(IMPLICIT_WAIT, 10);</span>
    }

    public static String getAppiumServerUrl() {
        // Padrão local se não definido no arquivo
<span class="fc" id="L196">        return getProperty(APPIUM_SERVER_URL, &quot;http://127.0.0.1:4723&quot;);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>